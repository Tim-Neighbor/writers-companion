using System;
using System.Collections.Generic;
using System.Drawing;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Controls.Primitives;
using System.Windows.Data;
using System.Windows.Documents;
using System.Windows.Forms;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Imaging;
using System.Windows.Navigation;
using System.Windows.Shapes;
using System.Windows.Threading;

/* Note to reader: This file is separated into sections
 * using the #region statement. Each region contains
 * methods that share a similar purpose.
 * It is recommended to first close all regions
 * in order to more easily
 * find methods and read this file.
 */

namespace TheWritersCompanion
{
    /// <summary>
    /// Interaction logic for MainWindow.xaml
    /// The primary editor window for the project.
    /// Author: Dylan Schulz
    /// Some methods written by Ty Larson
    /// .xaml file created by Dylan Schulz based
    ///     on prototype by Rudy Fisher
    /// </summary>
    public partial class MainWindow : Window, IUserInterface
    {
        #region Fields

        // The directory of the current project
        private string projectDirectory;

        // The IController used by this IUserInterface
        private IController controller;

        // Name of the currently displayed category
        private string currentCategoryName;

        // Name of the currently displayed note
        private string currentNoteName;

        // Current zoom level of note rich text box
        private float currentZoomFactor = 1.0f;
       
        // Timer used for autosaving
        private DispatcherTimer autosaveTimer;

        #endregion

        #region Properties

        /// <summary>
        /// The directory of the current project
        /// </summary>
        public string ProjectDirectory
        {
            get
            {
                return projectDirectory;
            }
        }

        #endregion

        #region Constants

        // Default font info for the note rich text box
        private const string DEFAULT_NOTE_TB_FONT_FAMILY = "Segoe UI";
        private const int DEFAULT_NOTE_TB_FONT_SIZE = 11;
        private const GraphicsUnit DEFAULT_NOTE_TB_FONT_SIZE_UNIT =
            GraphicsUnit.Point;

        // Possible values for saveStatusLabel
        private const string SAVE_STATUS_UNSAVED = "Unsaved";
        private const string SAVE_STATUS_SAVED = "Saved";
        private const string SAVE_STATUS_SAVING = "Saving...";
        private const string SAVE_STATUS_SYNCED = "Synced";
        private const string SAVE_STATUS_SYNCING = "Syncing...";
        private const string SAVE_STATUS_SYNCFAIL = "Sync fail";

        // Title for MessageBoxes generated by this window
        private const string MESSAGE_BOX_TITLE = "The Writer's Companion";

        // Format strings for delete MessageBoxes
        private const string DELETE_CATEGORY_MESSAGE_FORMAT_STR =
            "Are you sure you want to delete the \"{0}\" category? " +
            "This will also delete all notes within that category!";
        private const string DELETE_NOTE_MESSAGE_FORMAT_STR =
            "Are you sure you want to " +
            "delete the \"{0}\" note within the \"{1}\" category?";

        // Values for zooming the note rich text box
        // Internal zoom factor * multiplier = user-inputted zoom factor
        private const float ZOOM_FACTOR_MULTIPLIER = 100.0f;
        private const float ZOOM_FACTOR_MIN = 0.015625f;
        private const float ZOOM_FACTOR_MAX = 64.0f;
        private const float ZOOM_FACTOR_DEFAULT = 1.0f;

        // Value for the autosave timer interval
        private const int AUTOSAVE_INTERVAL_SEC = 10;

        #endregion

        #region ConstructorsAndInitMethods

        /// <summary>
        /// Creates this IUserInterface MainWindow and
        /// initializes it. Sets extra UI settings, loads project data,
        /// and starts the autosave timer.
        /// </summary>
        /// <param name="projectDirectory">The directory for the
        /// current project</param>
        /// <param name="isNewProject">Whether a new
        /// project is being created or an existing one
        /// is being loaded</param>
        /// <param name="controller">The IController that this
        /// IUserInterface will use.</param>
        public MainWindow(string projectDirectory, bool isNewProject,
            IController controller)
        {
            InitializeComponent();

            InitializeExtraUISettings();

            // Load the actual project information

            LoadProject(projectDirectory, isNewProject, controller);

            // Begin the autosave timer

            InitializeAutosaveTimer();
        }

        /// <summary>
        /// Load into the program the project that is in the given directory.
        /// </summary>
        /// <param name="projectDirectory">The directory path for
        /// the project to load</param>
        /// <param name="isNewProject">Whether or not this project is
        /// a new project or a preexisting project</param>
        private void LoadProject(string projectDirectory, bool isNewProject,
            IController controller)
        {
            // Initialize to having no current note/directory

            currentNoteName = "";
            currentCategoryName = "";

            // Set project directory

            this.projectDirectory = projectDirectory;

            // Set controller
            
            this.controller = controller;

            // If the project is new, there is no information to update,
            // otherwise update and load names into the ComboBoxes
            if (!isNewProject)
            {
                UpdateCategoryComboBox();
                UpdateNoteComboBox();
            }
        }

        /// <summary>
        /// A helper method for the constructor that sets additional
        /// UI settings that must be set. In particular,
        /// it sets the location of the window
        /// and sets the default font and zoom for the rich text box.
        /// </summary>
        private void InitializeExtraUISettings()
        {
            // Set the window to dock on the left side of the screen

            Rect workArea = SystemParameters.WorkArea;
            Top = workArea.Top;
            Left = workArea.Left;
            Height = workArea.Height;

            // Set the default font for the editor text box

            System.Drawing.FontFamily textBoxFontFamily =
                new System.Drawing.FontFamily(DEFAULT_NOTE_TB_FONT_FAMILY);
            noteRichTextBox.Font = new Font(textBoxFontFamily,
                DEFAULT_NOTE_TB_FONT_SIZE, DEFAULT_NOTE_TB_FONT_SIZE_UNIT);

            // Set default zoom for the editor text box

            UpdateRTBZoom(ZOOM_FACTOR_DEFAULT);
        }

        /// <summary>
        /// Sets up and starts the autosave timer.
        /// </summary>
        private void InitializeAutosaveTimer()
        {
            autosaveTimer = new DispatcherTimer();

            // Set the method that is called at each interval

            autosaveTimer.Tick += new EventHandler(autosaveTimer_Tick);

            // Set the time to be the above constant in seconds

            autosaveTimer.Interval =
                new TimeSpan(0, 0, AUTOSAVE_INTERVAL_SEC);
            
            autosaveTimer.Start();
        }

        #endregion

        #region CreateMethods

        /// <summary>
        /// Ask the user for an input string name to create a new category.
        /// </summary>
        /// <returns>The Category that was created,
        /// or null if no category was created/</returns>
        public Category CreateCategory()
        {
            // Display a new window as a dialog box

            CreateCategoryWindow createCategoryWindow =
                new CreateCategoryWindow();
            createCategoryWindow.Owner = this;
            createCategoryWindow.ShowDialog();
            
            // If the user did not cancel in the dialog box,
            // then get the new category's name
            // and create it with the controller

            if (createCategoryWindow.DialogResult == true)
            {
                string newCategoryName = createCategoryWindow.CategoryName;
                OutcomeCode outcome
                    = controller.CreateCategory(newCategoryName);

                if (outcome != OutcomeCode.SUCCESS)
                {
                    DisplayOutcomeMessageBox(outcome);
                    return null;
                }
                else
                {
                    return new Category(newCategoryName);
                }
            }
            else
            {
                // If the user canceled, no Category was created

                return null;
            }
        }

        /// <summary>
        /// Ask the user for a Category and an input string name
        /// to create a new Note.
        /// </summary>
        /// <returns>The Note that was created,
        /// or null if no note was created</returns>
        public Note CreateNote()
        {
            // Get all possible categories to display as choices

            List<Category> categories = controller.GetAllCategories();

            // Display a new window as a dialog box

            CreateNoteWindow createNoteWindow =
                new CreateNoteWindow(categories, currentCategoryName);
            createNoteWindow.Owner = this;
            createNoteWindow.ShowDialog();

            // If the user did not cancel in the dialog box,
            // then get the new category's name
            // and create it with the controller

            if (createNoteWindow.DialogResult == true)
            {
                string newNoteName = createNoteWindow.NoteName;
                string newNotesCategoryName = createNoteWindow.CategoryName;
                
                OutcomeCode outcome = controller.CreateNote(newNoteName,
                    newNotesCategoryName);
                
                if (outcome != OutcomeCode.SUCCESS)
                {
                    DisplayOutcomeMessageBox(outcome);
                    return null;
                }
                else
                {
                    Category newNotesCategory =
                        new Category(newNotesCategoryName);
                    return new Note(newNoteName, newNotesCategory);
                }
            }
            else
            {
                // If the user canceled, no note was created

                return null;
            }
        }

        /// <summary>
        /// Handles a click on the newCategoryButton by attempting to
        /// create a new category. Updates the category list
        /// and switches to the new category if a category was created.
        /// </summary>
        /// <param name="sender">The control that sent this event</param>
        /// <param name="e">Event args for this event</param>
        private void newCategoryButton_Click(object sender, RoutedEventArgs e)
        {
            Category newCategory = CreateCategory();

            if (newCategory != null)
            {
                UpdateCategoryComboBox();

                // Switch to new category

                categoryComboBox.SelectedItem = newCategory.Name;
            }
        }

        /// <summary>
        /// Handles a click on the newNoteButton by attempting to
        /// create a new note. Updates the note list
        /// and switches to the new note if a note was crated.
        /// </summary>
        /// <param name="sender">The control that sent this event</param>
        /// <param name="e">Event args for this event</param>
        private void newNoteButton_Click(object sender, RoutedEventArgs e)
        {
            Note newNote = CreateNote();

            if (newNote != null)
            {
                UpdateNoteComboBox();

                // Switch to new note and its category

                Category newNotesCategory = newNote.Category;

                categoryComboBox.SelectedItem = newNotesCategory.Name;
                noteComboBox.SelectedItem = newNote.Name;
            }
        }

        #endregion

        #region RemoveMethods

        /// <summary>
        /// Asks the user if they want to remove the current category
        /// and does so if the user answers yes.
        /// All notes in the category are also deleted.
        /// </summary>
        /// <returns>true if a category was removed successfuly,
        /// false otherwise</returns>
        public bool RemoveCategory()
        {
            // If no category is selected, don't attempt to delete

            if (!currentCategoryName.Equals(""))
            {
                // Create a yes/no message box to ask the question

                string message = string.Format(
                    DELETE_CATEGORY_MESSAGE_FORMAT_STR, currentCategoryName);

                MessageBoxResult questionResult =
                    System.Windows.MessageBox.Show(message,MESSAGE_BOX_TITLE,
                    MessageBoxButton.YesNo, MessageBoxImage.Warning,
                    MessageBoxResult.No);

                // If the user answered yes, then try to remove the category
                // in the controller

                if (questionResult == MessageBoxResult.Yes)
                {
                    OutcomeCode outcome
                        = controller.RemoveCategory(currentCategoryName);

                    if (outcome != OutcomeCode.SUCCESS)
                    {
                        DisplayOutcomeMessageBox(outcome);
                    }

                    return true;
                }
            }
            else
            {
                DisplayOutcomeMessageBox(OutcomeCode.CATEGORY_NOT_SELECTED);
            }

            return false;
        }

        /// <summary>
        /// Asks the user if they want to remove the current note
        /// and does so if the user answers yes.
        /// </summary>
        /// <returns>true if a note was removed successfully,
        /// false otherwise</returns>
        public bool RemoveNote()
        {
            // If no note is selected, don't attempt to delete

            if (!currentNoteName.Equals(""))
            {
                // Create a yes/no message box to ask the question

                string message = string.Format(DELETE_NOTE_MESSAGE_FORMAT_STR,
                    currentNoteName, currentCategoryName);

                MessageBoxResult questionResult =
                    System.Windows.MessageBox.Show(message, MESSAGE_BOX_TITLE,
                    MessageBoxButton.YesNo, MessageBoxImage.Warning,
                    MessageBoxResult.No);

                // If the user answered yes, then try to remove the note
                // in the controller

                if (questionResult == MessageBoxResult.Yes)
                {
                    OutcomeCode outcome =
                        controller.RemoveNote(currentNoteName,
                        currentCategoryName);

                    if (outcome != OutcomeCode.SUCCESS)
                    {
                        DisplayOutcomeMessageBox(outcome);
                    }

                    return true;
                }
            }
            else
            {
                DisplayOutcomeMessageBox(OutcomeCode.NOTE_NOT_SELECTED);
            }

            return false;
        }

        /// <summary>
        /// Handles a click on the deleteCategoryButton by attempting
        /// to delete current category and all notes within it.
        /// If category was removed, update category and note
        /// selections and lists appropriately.
        /// </summary>
        /// <param name="sender">The control that sent this event</param>
        /// <param name="e">Event args for this event</param>
        private void deleteCategoryButton_Click(object sender,
            RoutedEventArgs e)
        {
            bool categoryRemoved = RemoveCategory();

            if (categoryRemoved)
            {
                currentCategoryName = "";
                currentNoteName = "";
                
                UpdateCategoryComboBox();
                UpdateNoteComboBox();
                
                // Deselect current selection in boxes

                categoryComboBox.SelectedIndex = -1;
                noteComboBox.SelectedIndex = -1;
            }
        }

        /// <summary>
        /// Handles a click on the deleteNoteButton by attempting
        /// to delete current note.
        /// If note was removed, update note
        /// selections and lists appropriately.
        /// </summary>
        /// <param name="sender">The control that sent this event</param>
        /// <param name="e">Event args for this event</param>
        private void deleteNoteButton_Click(object sender, RoutedEventArgs e)
        {
            bool noteRemoved = RemoveNote();

            if (noteRemoved)
            {
                currentNoteName = "";
                
                UpdateNoteComboBox();
                
                // Deselect current selection in box
                
                noteComboBox.SelectedIndex = -1;
            }
        }

        #endregion

        #region SaveMethods

        /// <summary>
        /// Saves the current content of the editor rich text box
        /// as the given note in the given category using controller.
        /// If the user can edit the note, the user is notified
        /// of saving status through the saveStatusLabel.
        /// </summary>
        /// <param name="noteName">The note name to save to</param>
        /// <param name="categoryName">The category name to save to</param>
        public void SaveNote(string noteName, string categoryName)
        {
            // If the given note does not exist, do not try to save it

            if (!noteName.Equals(""))
            {
                // If user can edit note, notify them of change

                if (noteRichTextBox.Enabled)
                {
                    saveStatusLabel.Content = SAVE_STATUS_SAVING;
                }

                OutcomeCode outcome = controller.SaveNote(noteName,
                    categoryName, noteRichTextBox.Rtf);

                if (outcome != OutcomeCode.SUCCESS)
                {
                    DisplayOutcomeMessageBox(outcome);
                }

                // If user can edit note, notify them of change

                if (noteRichTextBox.Enabled)
                {
                    saveStatusLabel.Content = SAVE_STATUS_SAVED;
                }
            }
        }

        /// <summary>
        /// Save the currently displayed and selected note
        /// into the local storage directory.
        /// </summary>
        /// <see cref="SaveNote(string, string)"/>
        private void SaveCurrentNote()
        {
            SaveNote(currentNoteName, currentCategoryName);
        }

        /// <summary>
        /// Handles a click on the saveButton by saving the
        /// currently displayed and selected note.
        /// </summary>
        /// <see cref="SaveCurrentNote"/>
        /// <param name="sender">The control that sent this event</param>
        /// <param name="e">Event args for this event</param>
        private void saveButton_Click(object sender, RoutedEventArgs e)
        {
            SaveCurrentNote();
        }

        /// <summary>
        /// Handles the closing of the mainWindow.
        /// When window closes, save the current note.
        /// </summary>
        /// <see cref="SaveCurrentNote"/>
        /// <param name="sender">The control that sent this event</param>
        /// <param name="e">Event args for this event</param>
        private void mainWindow_Closed(object sender, EventArgs e)
        {
            SaveCurrentNote();
        }

        /// <summary>
        /// Runs each time the autosaveTimer finishes its
        /// countdown (i.e. when it ticks).
        /// When the timer ticks, save the current note.
        /// </summary>
        /// <see cref="SaveCurrentNote"/>
        /// <param name="sender">The object that sent this event</param>
        /// <param name="e">Event args for this event</param>
        private void autosaveTimer_Tick(object sender, EventArgs e)
        {
            SaveCurrentNote();
        }

        #endregion

        #region UpdateAndComboBoxMethods

        /// <summary>
        /// Update the list of categories in the ComboBox.
        /// Clear the box and reget the list of categories from controller.
        /// </summary>
        private void UpdateCategoryComboBox()
        {
            categoryComboBox.Items.Clear();

            // Get all categories from controller and add to the ComboBox

            List<Category> categories = controller.GetAllCategories();

            foreach (Category category in categories)
            {
                categoryComboBox.Items.Add(category.Name);
            }
        }

        /// <summary>
        /// Update the list of notes in the ComboBox.
        /// Clear the box and reget all notes from controller,
        /// adding only if part of current category.
        /// </summary>
        private void UpdateNoteComboBox()
        {
            noteComboBox.Items.Clear();

            // Get all notes from controller

            List<Note> notes = controller.GetAllNotes();

            foreach (Note note in notes)
            {
                // Add to the combo box only
                // if the note is a part of the current category

                if (note.Category.Name.Equals(currentCategoryName))
                {
                    noteComboBox.Items.Add(note.Name);
                }
            }
        }

        /// <summary>
        /// Update the display in the noteRichTextBox with
        /// whatever note is referred to by the current note string field.
        /// If no note is selected, clear the box.
        /// </summary>
        private void UpdateCurrentNote()
        {
            if (!currentNoteName.Equals(""))
            {
                Note updatedNote = controller.GetNote(currentNoteName,
                    currentCategoryName);
                noteRichTextBox.Rtf = updatedNote.Content;
            }
            else
            {
                noteRichTextBox.Rtf = "";
            }
        }

        /// <summary>
        /// Handles when the text in the noteRichTextBox is changed.
        /// If the text is enabled for user input,
        /// notify the user that content is unsaved.
        /// </summary>
        /// <param name="sender">The control that sent this event</param>
        /// <param name="e">Event args for this event</param>
        private void noteRichTextBox_TextChanged(object sender, EventArgs e)
        {
            if (noteRichTextBox.Enabled)
            {
                saveStatusLabel.Content = SAVE_STATUS_UNSAVED;
            }

        }

        /// <summary>
        /// Handles when the enabled property of the noteRichTextBox
        /// is changed.
        /// When the box enables, a note will be freshly loaded
        /// from storage, so notify the user that it is saved.
        /// When the box disables, clear the save notification.
        /// </summary>
        /// <param name="sender">The control that sent this event</param>
        /// <param name="e">Event args for this event</param>
        private void noteRichTextBox_EnabledChanged(object sender,
            EventArgs e)
        {
            if (noteRichTextBox.Enabled)
            {
                saveStatusLabel.Content = SAVE_STATUS_SAVED;
            }
            else
            {
                saveStatusLabel.Content = "";
            }
        }

        /// <summary>
        /// Handle a change in selection in the categoryComboBox
        /// by saving and removing the currently displayed note,
        /// saving the current zoom,
        /// and updating current categories and notes.
        /// </summary>
        /// <param name="sender">The control that sent this event</param>
        /// <param name="e">Event args for this event</param>
        private void categoryComboBox_SelectionChanged(object sender,
            SelectionChangedEventArgs e)
        {
            // Get selected category or lack thereof

            string selectedCategory;

            if (categoryComboBox.SelectedItem == null)
            {
                selectedCategory = "";
            }
            else
            {
                selectedCategory = categoryComboBox.SelectedItem.ToString();
            }

            // Disable editing since a note will not be selected

            noteRichTextBox.Enabled = false;

            // Save old note info to storage

            SaveCurrentNote();

            // Store current zoom if there was a current note
            
            if (!currentNoteName.Equals(""))
            {
                UpdateStoredZoomToActual();
            }

            // Reset note info locally

            noteRichTextBox.Rtf = "";
            currentNoteName = "";

            // Set new category information and load correct notes

            currentCategoryName = selectedCategory;
            UpdateNoteComboBox();
        }

        /// <summary>
        /// Handle a change in selection in the noteComboBox
        /// by saving the currently displayed note and zoom,
        /// replacing old note with the newly selected note,
        /// and updating the current note name and other display features.
        /// </summary>
        /// <param name="sender">The control that sent this event</param>
        /// <param name="e">Event args for this event</param>
        private void noteComboBox_SelectionChanged(object sender,
            SelectionChangedEventArgs e)
        {
            // Get selected note or lack thereof

            string selectedNote;

            if (noteComboBox.SelectedItem == null)
            {
                selectedNote = "";
            }
            else
            {
                selectedNote = noteComboBox.SelectedItem.ToString();
            }

            // Disable editing while modifying

            noteRichTextBox.Enabled = false;

            // Save old information

            if (!currentNoteName.Equals(""))
            {
                UpdateStoredZoomToActual();
            }
            
            SaveCurrentNote();

            // Set new information and update formatting

            currentNoteName = selectedNote;
            UpdateCurrentNote();
            UpdateFormattingToggleButtons();
            UpdateRTBZoom(currentZoomFactor);

            // Allow editing again, but only if there is a note

            if (!currentNoteName.Equals(""))
            {
                noteRichTextBox.Enabled = true;
            }
        }

        #endregion

        #region SyncToDatabaseMethods

        /// <summary>
        /// Ty Larson wrote this method.
        /// Minor modifications by Dylan Schulz.
        /// Syncs the project to the database.
        /// </summary>
        /// <param name="directory">Directory string of project</param>
        /// <param name="username">Username for database</param>
        /// <param name="password">Password for database</param>
        /// <returns>OutcomeCode for whether it succeeded
        /// or how it failed</returns>
        public OutcomeCode SyncToDatabase(string directory,
            string username, string password)
        {
            OutcomeCode credentialOutcome =
                controller.SetCredentials(username, password);

            if (credentialOutcome != OutcomeCode.SUCCESS)
            {
                DisplayOutcomeMessageBox(credentialOutcome);

                return credentialOutcome;
            }
            else
            {
                OutcomeCode syncOutcome =
                    controller.SyncToDatabase(directory, username, password);

                if (syncOutcome != OutcomeCode.SUCCESS)
                {
                    DisplayOutcomeMessageBox(syncOutcome);
                }

                return syncOutcome;
            }
        }

        /// <summary>
        /// Ty Larson wrote this method. Minor modifications by Dylan Schulz.
        /// Tells the controller to sync to the database
        /// </summary>
        /// <param name="sender">The control that sent this event</param>
        /// <param name="e">Event args for this event</param>
        private void syncButton_Click(object sender, RoutedEventArgs e)
        {
            saveStatusLabel.Content = SAVE_STATUS_SYNCING;

            SyncToBackupStorageWindow sync =
                new SyncToBackupStorageWindow(this);
            sync.ShowDialog();

            if (sync.DialogResult == true)
            {
                saveStatusLabel.Content = SAVE_STATUS_SYNCED;
            }
            else
            {
                saveStatusLabel.Content = SAVE_STATUS_SYNCFAIL;
            }
        }

        #endregion

        #region ErrorMethods

        /// <summary>
        /// Informs the user of errors when they occur.
        /// Pops up a message box giving them an error
        /// message based on the OutcomeCode
        /// </summary>
        /// <param name="outcome">The OutcomeCode representing
        /// the error to display</param>
        private void DisplayOutcomeMessageBox(OutcomeCode outcome)
        {
            // Translate the OutcomeCode into a user friendly string

            string message =
                OutcomeCodeTranslator.GetUserFriendlyErrorMessage(outcome);

            System.Windows.MessageBox.Show(message, MESSAGE_BOX_TITLE,
                MessageBoxButton.OK, MessageBoxImage.Error);
        }

        #endregion

        #region FormattingMethods

        /// <summary>
        /// Updates bold and italic formatting of the current
        /// selection in the noteRichTextBox to reflect
        /// the state of the bold and italic ToggleButtons.
        /// Gets the current font and applies a new font.
        /// </summary>
        private void UpdateBoldItalicFormatting()
        {
            // Get the current font

            Font currentFont = noteRichTextBox.SelectionFont;

            if (currentFont != null)
            {
                Font fontToApply;

                bool isBoldChecked = (bool)boldToggleButton.IsChecked;
                bool isItalicsChecked = (bool)italicsToggleButton.IsChecked;

                if (isBoldChecked)
                {
                    // Turn on bold and turn off italic
                    // (currentStyle | Bold) & ~Italic

                    fontToApply = new Font(currentFont, (currentFont.Style |
                        System.Drawing.FontStyle.Bold) &
                        ~System.Drawing.FontStyle.Italic);
                }
                else if (isItalicsChecked)
                {
                    // Turn on italic and turn off bold
                    // (currentStyle | Italic) & ~Bold

                    fontToApply = new Font(currentFont, (currentFont.Style |
                        System.Drawing.FontStyle.Italic) &
                        ~System.Drawing.FontStyle.Bold);
                }
                else // if neither is checked
                {
                    // Turn off italic and turn off bold
                    // currentStyle & ~Bold & ~Italic
                    fontToApply = new Font(currentFont, currentFont.Style &
                        ~System.Drawing.FontStyle.Bold &
                        ~System.Drawing.FontStyle.Italic);
                }

                noteRichTextBox.SelectionFont = fontToApply;
            }
            else
            {
                // Only one font may be selected at a time,
                // or SelectionFont will be null
                // and checking it will not work

                DisplayOutcomeMessageBox(OutcomeCode.MULTIPLE_FONTS_SELECTED);
            }
        }

        /// <summary>
        /// Updates bullet point formatting of the current
        /// selection in the noteRichTextBox to reflect
        /// the current state of the boldToggleButton.
        /// </summary>
        private void UpdateBulletFormatting()
        {
            bool isBulletChecked = (bool)bulletToggleButton.IsChecked;

            if (isBulletChecked)
            {
                noteRichTextBox.SelectionBullet = true;
            }
            else
            {
                noteRichTextBox.SelectionBullet = false;
            }
        }

        /// <summary>
        /// Almost same as what Rudy wrote
        /// Update the state of the bold, italic, and bullet
        /// ToggleButtons to reflect the state of the currently
        /// selected text in the noteRichTextBox.
        /// </summary>
        private void UpdateFormattingToggleButtons()
        {
            Font currentFont = noteRichTextBox.SelectionFont;

            if (currentFont != null)
            {
                UpdateToggleButtonCheckedState(boldToggleButton,
                    currentFont.Bold);
                UpdateToggleButtonCheckedState(italicsToggleButton,
                    currentFont.Italic);
            }

            UpdateToggleButtonCheckedState(bulletToggleButton,
                noteRichTextBox.SelectionBullet);
        }

        /// <summary>
        /// Almost same as what Rudy wrote.
        /// Change the checked state of a ToggleButton as inputted.
        /// </summary>
        /// <param name="button">The ToggleButton to change</param>
        /// <param name="shouldBeChecked">true if you want to check the
        /// button, false if you want to uncheck the button</param>
        private void UpdateToggleButtonCheckedState(ToggleButton button,
            bool shouldBeChecked)
        {
            button.IsChecked = shouldBeChecked;
        }

        /// <summary>
        /// Flips the current checked state of a ToggleButton.
        /// If the button is checked, uncheck it, and vice versa.
        /// </summary>
        /// <param name="button">The ToggleButton to change</param>
        private void FlipToggleButtonCheckedState(ToggleButton button)
        {
            bool isChecked = (bool)button.IsChecked;
            button.IsChecked = !isChecked;
        }

        /// <summary>
        /// Create and return a FontDialog box object
        /// with certain customizations.
        /// Set the default font and color for the dialog
        /// to be the current ones if possible,
        /// and require that the selected font
        /// must exist, and allow color selections.
        /// </summary>
        /// <returns>The customized FontDialog object</returns>
        private FontDialog CreateFontDialog()
        {
            // Create a dialog box to select font style

            FontDialog fontDialog = new FontDialog();

            // Require an existing font and allow selecting colors

            fontDialog.FontMustExist = true;
            fontDialog.ShowColor = true;

            // Set default font as current font if possible
            // If multiple current fonts, set default to
            // the overall default for the text box

            Font currentFont = noteRichTextBox.SelectionFont;

            if (currentFont != null)
            {
                fontDialog.Font = noteRichTextBox.SelectionFont;
            }
            else
            {
                System.Drawing.FontFamily defaultFontFamily
                    = new System.Drawing.FontFamily(
                    DEFAULT_NOTE_TB_FONT_FAMILY);
                fontDialog.Font = new Font(defaultFontFamily,
                    DEFAULT_NOTE_TB_FONT_SIZE,
                    DEFAULT_NOTE_TB_FONT_SIZE_UNIT);
            }

            // Set color as current color

            fontDialog.Color = noteRichTextBox.SelectionColor;

            return fontDialog;
        }

        /// <summary>
        /// Handles a click for the boldToggleButton
        /// by disabling the italic ToggleButton and
        /// updating the bold/italic formatting
        /// in the noteRichTextBox as appropriate.
        /// </summary>
        /// <param name="sender">The control that sent this event</param>
        /// <param name="e">Event args for this event</param>
        private void boldToggleButton_Click(object sender, RoutedEventArgs e)
        {
            bool isBoldChecked = (bool)boldToggleButton.IsChecked;
            
            if (isBoldChecked)
            {
                UpdateToggleButtonCheckedState(italicsToggleButton, false);
            }

            UpdateBoldItalicFormatting();
        }

        /// <summary>
        /// Handles a click for the italicsToggleButton
        /// by disabling the bold ToggleButton and
        /// updating the bold/italic formatting
        /// in the noteRichTextBox as appropriate.
        /// </summary>
        /// <param name="sender">The control that sent this event</param>
        /// <param name="e">Event args for this event</param>
        private void italicsToggleButton_Click(object sender,
            RoutedEventArgs e)
        {
            bool isItalicsChecked = (bool)italicsToggleButton.IsChecked;

            if (isItalicsChecked)
            {
                UpdateToggleButtonCheckedState(boldToggleButton, false);
            }

            UpdateBoldItalicFormatting();
        }

        /// <summary>
        /// Handles a click for the bulletToggleButton
        /// by updating the bullet formatting in the
        /// noteRichText box as approprite, if it is
        /// enabled.
        /// </summary>
        /// <param name="sender">The control that sent this event</param>
        /// <param name="e">Event args for this event</param>
        private void bulletToggleButton_Click(object sender,
            RoutedEventArgs e)
        {
            if (noteRichTextBox.Enabled)
            {
                UpdateBulletFormatting();
            }
        }

        /// <summary>
        /// Handles a click for the fontButton by
        /// bringing up a font dialog box and
        /// updating the selected font in the
        /// noteRichTextBox as instructed by the user.
        /// </summary>
        /// <param name="sender"></param>
        /// <param name="e"></param>
        private void fontButton_Click(object sender, RoutedEventArgs e)
        {
            FontDialog fontDialog = CreateFontDialog();
            
            // If the dialog is successful, update current values

            if (fontDialog.ShowDialog() ==
                System.Windows.Forms.DialogResult.OK)
            {
                noteRichTextBox.SelectionFont = fontDialog.Font;
                noteRichTextBox.SelectionColor = fontDialog.Color;
            }

            // In case bold/italic changed, update buttons

            UpdateFormattingToggleButtons();
        }

        /// <summary>
        /// Handles a change in the current text selection in the
        /// noteRichTextBox by updating the current
        /// status of the bold and italic ToggleButtons as appropriate.
        /// </summary>
        /// <param name="sender">The control that sent this event</param>
        /// <param name="e">Event args for this event</param>
        private void noteRichTextBox_SelectionChanged(object sender,
            EventArgs e)
        {
            UpdateFormattingToggleButtons();
        }

        #endregion

        #region ZoomMethods

        /// <summary>
        /// Updates the zoom factor of the noteRichTextBox to the
        /// given zoom factor, after checking whether it is in range.
        /// </summary>
        /// <param name="newZoomFactor">The internal zoom
        /// factor to set on the noteRichTextBox</param>
        /// <returns>An OutcomeCode representing a
        /// success or the error that occurred</returns>
        private OutcomeCode UpdateRTBZoom(float newZoomFactor)
        {
            if (newZoomFactor > ZOOM_FACTOR_MIN && newZoomFactor <
                ZOOM_FACTOR_MAX)
            {
                currentZoomFactor = newZoomFactor;

                // Must set to default first to get it
                // to work for some reason

                noteRichTextBox.ZoomFactor = ZOOM_FACTOR_DEFAULT;
                noteRichTextBox.ZoomFactor = newZoomFactor;

                return OutcomeCode.SUCCESS;
            }
            else
            {
                DisplayOutcomeMessageBox(
                    OutcomeCode.ZOOM_FACTOR_OUT_OF_RANGE);

                return OutcomeCode.ZOOM_FACTOR_OUT_OF_RANGE;
            }
        }

        /// <summary>
        /// Updated the zoom stored in the zoomTextBox
        /// to match the actual zoom of the noteRichTextBox
        /// </summary>
        private void UpdateStoredZoomToActual()
        {
            currentZoomFactor = noteRichTextBox.ZoomFactor;
            zoomTextBox.Text = (currentZoomFactor *
                ZOOM_FACTOR_MULTIPLIER).ToString();
        }

        /// <summary>
        /// When the zoomTextBox receives keyboard focus,
        /// then update the zoom stored in the text box
        /// to match the actual zoom factor of the noteRichTextBox
        /// </summary>
        /// <param name="sender">The control that sent this event</param>
        /// <param name="e">Event args for this event</param>
        private void zoomTextBox_GotKeyboardFocus(object sender,
            KeyboardFocusChangedEventArgs e)
        {
            UpdateStoredZoomToActual();
        }

        /// <summary>
        /// When the zoomTextBox loses keyboard focus,
        /// then try to update the zoom factor of the noteRichTextBox
        /// to match the zoom inputted in the zoomTextBox.
        /// If there is an error in the inputted zoom, display to user
        /// and reset the zoomTextBox to the actual zoom.
        /// </summary>
        /// <param name="sender">The control that sent this event</param>
        /// <param name="e">Event args for this event</param>
        /// <remarks>The conversion rate between the internal
        /// zoom factor and the user inputted zoom factor is
        /// represented as a constant in this class.</remarks>
        private void zoomTextBox_LostKeyboardFocus(object sender,
            KeyboardFocusChangedEventArgs e)
        {
            float userInputZoomFactor;

            // Attempt to convert the user inputted zoom into a float

            if (float.TryParse(zoomTextBox.Text.Trim(),
                out userInputZoomFactor))
            {
                // If successful, try to set new zoom factor

                float newZoomFactor = userInputZoomFactor /
                    ZOOM_FACTOR_MULTIPLIER;

                OutcomeCode outcome = UpdateRTBZoom(newZoomFactor);

                if (outcome == OutcomeCode.ZOOM_FACTOR_OUT_OF_RANGE)
                {
                    UpdateStoredZoomToActual();
                }
            }
            else
            {
                DisplayOutcomeMessageBox(
                    OutcomeCode.ZOOM_FACTOR_MALFORMATTED);

                UpdateStoredZoomToActual();
            }
        }

        #endregion

        #region KeyboardShortcutMethods

        /// <summary>
        /// Handle the pressing of a key in the noteRichTextBox
        /// and perform keyboard shortcuts as necessary.
        /// Checks whether the user has entered a valid keyboard
        /// shortcut and activates the control that the shortcut is for.
        /// </summary>
        /// <param name="sender">The control that sent this event</param>
        /// <param name="e">Event args for this event,
        /// containing the key that was pressed</param>
        private void noteRichTextBox_KeyDown(object sender,
            System.Windows.Forms.KeyEventArgs e)
        {
            bool suppressKeyPress = false;

            if (e.Modifiers.HasFlag(Keys.Control))
            {
                // Keyboard shortcuts with Control held down

                if (e.Modifiers.HasFlag(Keys.Shift))
                {
                    // Handle keyboard shortcuts with
                    // Control + Shift held down

                    suppressKeyPress = HandleControlShiftKeyboardShortcuts(e);
                }
                else
                {
                    // Handle keyboard shortcuts with Control held down
                    // but Shift not held down

                    suppressKeyPress = HandleControlKeyboardShortcuts(e);
                }
            }

            // If we had a valid shortcut, then
            // suppress the key press so other controls
            // do not try to handle the shortcut as well

            if (suppressKeyPress)
            {
                e.SuppressKeyPress = true;
            }
        }

        /// <summary>
        /// Helper method for noteRichTextBox_KeyDown that handles
        /// keyboard shortcuts where control is held down but not shift.
        /// Activates the necessary button.
        /// </summary>
        /// <param name="e">Event args for the KeyDown event
        /// containing the key that was pressed</param>
        /// <returns>true if the key press should be
        /// suppressed because a valid shortcut was already handled,
        /// false otherwise</returns>
        private bool HandleControlKeyboardShortcuts(
            System.Windows.Forms.KeyEventArgs e)
        {
            switch (e.KeyCode)
            {
                case Keys.I:
                    FlipToggleButtonCheckedState(italicsToggleButton);
                    RaiseButtonClickEvent(italicsToggleButton);
                    return true;
                case Keys.B:
                    FlipToggleButtonCheckedState(boldToggleButton);
                    RaiseButtonClickEvent(boldToggleButton);
                    return true;
                case Keys.Q:
                    FlipToggleButtonCheckedState(bulletToggleButton);
                    RaiseButtonClickEvent(bulletToggleButton);
                    return true;
                case Keys.F:
                    RaiseButtonClickEvent(fontButton);
                    return true;
                case Keys.S:
                    RaiseButtonClickEvent(saveButton);
                    return true;
                case Keys.N:
                    RaiseButtonClickEvent(newNoteButton);
                    return true;
                default:
                    return false;
            }
        }

        /// <summary>
        /// Helper method for noteRichTextBox_KeyDown that handles
        /// keyboard shortcuts where control and shift are held down.
        /// Activates the necessary button.
        /// </summary>
        /// <param name="e">Event args for the KeyDown event
        /// containing the key that was pressed</param>
        /// <returns>true if the key press should be suppressed
        /// (such as because a valid shortcut was already handled),
        /// false otherwise</returns>
        private bool HandleControlShiftKeyboardShortcuts(
            System.Windows.Forms.KeyEventArgs e)
        {
            switch (e.KeyCode)
            {
                case Keys.N:
                    RaiseButtonClickEvent(newCategoryButton);
                    return true;
                case Keys.L:
                    // Suppressed to disable undesired default
                    // functionality for this shortcut
                    return true;
                default:
                    return false;
            }
        }

        /// <summary>
        /// Activates the Click event on the given button.
        /// </summary>
        /// <param name="button">The button to click, which can
        /// be various types of buttons.</param>
        private void RaiseButtonClickEvent(
            System.Windows.Controls.Primitives.ButtonBase button)
        {
            button.RaiseEvent(new RoutedEventArgs(
                System.Windows.Controls.Primitives.ButtonBase.ClickEvent));
        }

        #endregion
    }
}
